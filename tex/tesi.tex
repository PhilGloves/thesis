\documentclass[a4paper,11pt,titlepage,twoside]{book}

\usepackage{xcolor}
\usepackage{graphicx}

\usepackage{mathrsfs}
\usepackage{array,epsfig}
\usepackage{amsmath}
\usepackage{eufrak}
\usepackage{amsfonts}
%\usepackage{mathbbol}
\usepackage{amssymb}
\usepackage{amsxtra}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{tikz-cd}
\usepackage{enumerate}
\usepackage{tikz}
\usepackage{lmodern}
\usepackage[english]{babel}
\usepackage{geometry}
\geometry{a4paper,top=3cm,bottom=3cm,left=3.5cm,right=3.5cm,heightrounded,bindingoffset=5mm}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{emptypage}
%\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{enumerate}
\usepackage{indentfirst}
\usepackage{MnSymbol}


\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\CP}{\mathbb{CP}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\LC}{\mathcal{L}}
\newcommand{\support}{\mathrm{support}}
\newcommand{\Oset}{\varnothing}
\newcommand{\1}{\mathbf{1}}
\DeclareMathOperator{\id}{id}

\numberwithin{equation}{chapter}
\renewcommand{\theequation}{\thechapter.\arabic{equation}}
%per gli spazi:
\usepackage{setspace}
\singlespacing

\providecommand\phantomsection{}




%\usepackage{stmaryrd} 

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[chapter] % reset theorem numbering for each chapter

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition} % definition numbers are dependent on theorem numbers
\newtheorem{ex}[thm]{Example} % same for example numbers
\newtheorem{rmk}[thm]{Remark}
\newtheorem{notn}[thm]{Notation}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}

%Here I define some theorem styles and shortcut commands for symbols I use often





%Pagination stuff.
\setlength{\topmargin}{-.3 in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textheight}{9.in}
\setlength{\textwidth}{6.5in}
\pagestyle{empty}


\DeclareMathOperator{\obj}{Obj}
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\mor}{Mor}
\DeclareMathOperator{\iso}{Iso}
\DeclareMathOperator{\ve}{vect}
%\DeclareMathOperator{\diff}{diffmfd}
\DeclareMathOperator{\g}{\mathfrak{g}}
%\DeclareMathOperator{\1}{\mathbb{1}} REPLACED WITH \newcommand{\1}{\mathbf{1}}

%\DeclareMathOperator{\del}{\partial\!}
\newcommand{\del}{\partial}
\DeclareMathOperator{\grad}{grad}
\DeclareMathOperator{\ind}{ind}
\DeclareMathOperator{\ch}{ch}
\DeclareMathOperator{\td}{Td}
\DeclareMathOperator{\pf}{pf}   
\DeclareMathOperator{\cl}{Cl}  
\DeclareMathOperator{\htimes}{\hat{\otimes}}   
\DeclareRobustCommand{\rchi}{{\mathpalette\irchi\relax}}
\newcommand{\irchi}[2]{\raisebox{\depth}{$#1\chi$}} % inner command, used by \rchi

\newcommand{\vect}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}

% For Spin Geometry
\DeclareMathOperator{\diff}{\operatorname{Diff}}

% Lineare Algebra %
\DeclareMathOperator{\rg}{rg}     % Rang
\DeclareMathOperator{\diag}{diag} % Diagonalmatrix
\DeclareMathOperator{\Mat}{M}   % Matritzenraum
\DeclareMathOperator{\Eig}{Eig}   % Eigenräume
\DeclareMathOperator{\End}{End} 
\DeclareMathOperator{\Span}{Span} % lineare Huelle
\DeclareMathOperator{\adj}{adj}   % Adjungierte
\DeclareMathOperator{\Ann}{Ann}   % Annihilator
\DeclareMathOperator{\Aut}{Aut}   % Automorphismen Gruppe
\DeclareMathOperator{\Sp}{Sp}     % Symplektische Gruppe
\DeclareMathOperator{\GL}{GL}     % Allgemeine Lineare Gruppe

\DeclareMathOperator{\Tr}{Tr}     % Spur
\DeclareMathOperator{\Ker}{Ker}   % Kern 
\DeclareMathOperator{\Bild}{Im}   % Bild
\DeclareMathOperator{\Hom}{Hom}   % Homomorphismen
\DeclareMathOperator{\sgn}{sgn}   % Signum
\DeclareMathOperator{\Deg}{Deg}   % Degree
\DeclareMathOperator{\vol}{vol}   % Signum


%\usepackage[backend=bibtex,
%style=alphabetic,
%sorting=ynt]{biblatex}
%\addbibresource{Lit.bib}

\setlength\parindent{24pt}


\newcommand{\bigzero}{\mbox{\normalfont\Large\bfseries 0}}
\newcommand{\rvline}{\hspace*{-\arraycolsep}\vline\hspace*{-\arraycolsep}}

\usepackage{wasysym}
%\newcommand{\heart}{\gamma}
\renewcommand\epsilon{\varepsilon}
\renewcommand\phi{\varphi}


\usepackage{fontspec}
\newfontfamily\TahomaFont[
Scale=1,Ligatures={TeX},
BoldFont={Tahoma Bold}, 
ItalicFont={Verdana Italic},
]{Tahoma}

\usepackage[absolute]{textpos}

\begin{document}
	\onehalfspacing
	\thispagestyle{empty}
	
	\begingroup
	\TahomaFont
	
	\begin{textblock*}{4cm}(8.65cm,1.03cm)
		\centerline {\includegraphics[width=3.67cm]{LogoUniToConvertito.png}}
	\end{textblock*}
	
	
	\begin{textblock*}{21cm}(0cm,8.98cm)
		\fontsize{18}{22}\selectfont
		\centerline {\textbf{ Universit\`a degli Studi di Torino}}
	\end{textblock*}
	\begin{textblock*}{21cm}(0cm,9.97cm)
		\fontsize{18}{22}\selectfont
		\centerline {\textit{ Corso di Laurea in Informatica}}
	\end{textblock*}
	
	
	\begin{textblock*}{21cm}(0cm,12.66cm)
		\fontsize{20}{24}\selectfont
		\center  {\textbf{Pipeline computazionale per la fabbricazione \\ digitale di scratch hologram: \\ dal modello 3D al G-Code }}
	\end{textblock*}
	\begin{textblock*}{21cm}(0cm,16.46cm)
		\fontsize{18}{22}\selectfont
		\centerline{\Large {Tesi di Laurea Triennale}}
	\end{textblock*}
	
	
	
	\fontsize{14}{17}\selectfont
	
	\begin{textblock*}{8cm}(3.04cm,20.26cm)
		\noindent 
		\textbf{Relatore}
	\end{textblock*}
	\begin{textblock*}{8cm}(3.04cm,20.85cm)
		\noindent 
		Bioglio Valerio
	\end{textblock*}
	
	\begin{textblock*}{8cm}(12.33cm,22.95cm)
		\noindent
		\textbf{Candidato/a}
	\end{textblock*}
	\begin{textblock*}{8cm}(12.33cm,23.55cm)
		\noindent	\textbf{Guanti Filippo}
	\end{textblock*}
	\begin{textblock*}{8cm}(12.33cm,24.14cm)
		\noindent	Matricola 893412
	\end{textblock*}
	
	\begin{textblock*}{21cm}(0cm,27.34cm)
		\centerline{Anno Accademico 2024/2025}
	\end{textblock*}
	
	\endgroup
	
	
	\clearpage
	\thispagestyle{empty}
	\null
	\clearpage
	
	\TPoptions{absolute=false}
	\pagestyle{plain}
	\frontmatter
	
	%\newpage
	
	% ----- Pagina dichiarazione -----
	\thispagestyle{empty}
	
	\vspace*{4cm}
	
	\begin{center}
		\begin{minipage}{0.8\textwidth}
			\small
			Dichiaro di essere responsabile del contenuto dell’elaborato che 
			presento al fine del conseguimento del titolo, di non avere plagiato in tutto o in parte il lavoro prodotto da altri e di aver citato
			le fonti originali in modo congruente alle normative vigenti in
			materia di plagio e di diritto d’autore. Sono inoltre consapevole
			che nel caso la mia dichiarazione risultasse mendace, potrei incorrere nelle sanzioni previste dalla legge e la mia ammissione
			alla prova finale potrebbe essere negata.
		\end{minipage}
	\end{center}
	
	\clearpage
	
	% ----- Pagina vuota -----
	\thispagestyle{empty}
	\null
	\clearpage
	
	
	% ----- ABSTRACT -----
	\thispagestyle{plain}
	
	\chapter*{Abstract}
	\addcontentsline{toc}{chapter}{Abstract}
	
	Gli scratch hologram rappresentano una tecnica di olografia analogica che consente di ottenere l’illusione di profondità tridimensionale attraverso l’incisione di micro-traiettorie su superfici riflettenti. La progettazione di tali strutture richiede la trasformazione di informazioni geometriche tridimensionali in percorsi di incisione compatibili con sistemi di fabbricazione digitale. Questa tesi presenta una pipeline software per la generazione di scratch hologram a partire da modelli tridimensionali in formato STL, finalizzata alla generazione di traiettorie di incisione su superfici riflettenti. L’approccio adottato, implementato in Python, integra il caricamento della mesh, l’estrazione e il campionamento degli spigoli, la proiezione sul piano 2D e la generazione di archi secondo un modello geometrico semplificato di riflessione speculare. Il sistema produce output in formato SVG e G-code, in funzione della geometria delle traiettorie generate. È stata inoltre sviluppata un’applicazione desktop per la preview interattiva e la regolazione dei parametri principali, garantendo coerenza tra simulazione ed esportazione. Il contributo del lavoro consiste nello sviluppo di una soluzione riproducibile e indipendente da strumenti proprietari, concepita come base estendibile per l’ottimizzazione dei percorsi CNC, la validazione sperimentale e future applicazioni nella fabbricazione di scratch hologram.
	
	\clearpage
	
	\tableofcontents
	\clearpage
	
	\mainmatter
	
	\chapter{Introduzione}
	
	\begin{center}
		\begin{minipage}{1\textwidth}
			\normalsize
			CANCELLAREEEEEEEEEEEEEEEE
			
			
			
			
			Tra queste rientrano gli scratch hologram, una tecnica di olografia analogica in cui l’illusione di profondità non è ottenuta attraverso interferenza coerente, ma tramite incisioni opportunamente orientate su una superficie riflettente. In questo contesto la tridimensionalità percepita nasce dal comportamento speculare della luce: ogni micro-incisione produce un punto luminoso che si sposta al variare del punto di vista, contribuendo alla ricostruzione visiva di una forma tridimensionale virtuale.
			Se da un lato la realizzazione manuale di scratch hologram è nota da tempo in ambito artistico e sperimentale, dall’altro la loro generazione a partire da modelli tridimensionali digitali rappresenta un problema computazionale non banale. Non si tratta semplicemente di “proiettare” un modello su un piano, ma di tradurre informazioni geometriche tridimensionali in traiettorie di incisione bidimensionali compatibili con sistemi di fabbricazione numerica.
			Il punto centrale del problema può essere formulato in questo modo: dato un modello 3D espresso come mesh triangolare, come è possibile generare un insieme di percorsi macchina tali da produrre, su una superficie piana, un effetto visivo coerente con la forma originale? In altre parole, come si passa dal modello 3D al G-code in modo sistematico, riproducibile e indipendente da strumenti proprietari?
			La presente tesi affronta questo problema attraverso lo sviluppo di una pipeline computazionale implementata in Python. Il sistema accetta in ingresso un modello tridimensionale in formato STL, estrae e campiona i suoi spigoli, li proietta su un piano bidimensionale secondo una configurazione di vista controllata e genera traiettorie di incisione sotto forma di archi. Le traiettorie così ottenute possono essere esportate in formato SVG per la visualizzazione e in G-code per l’eventuale fabbricazione su macchina CNC.
			L’obiettivo non è quello di implementare un modello fisico completo della riflessione luminosa, ma di formalizzare e rendere riproducibile un approccio geometrico semplificato, sufficiente a produrre un effetto speculare qualitativamente coerente. La pipeline è accompagnata da un’applicazione desktop per la preview interattiva e dalla possibilità di validare visivamente i risultati mediante rendering in ambiente tridimensionale.
			Il contributo del lavoro consiste dunque nella definizione formale del problema, nella progettazione di un’architettura software coerente con tale formalizzazione e nella realizzazione di un sistema capace di collegare in modo diretto un modello 3D alla generazione di codice macchina per incisione.
		\end{minipage}
	\end{center}
	
	\section{Contesto e motivazioni}
	La rappresentazione tridimensionale di oggetti tramite modelli digitali è oggi uno standard consolidato in ambito informatico e ingegneristico. Formati come STL descrivono una superficie attraverso una mesh triangolare, permettendo di manipolare, visualizzare e fabbricare oggetti fisici a partire da una geometria discreta. In molti casi, il passaggio dal modello 3D alla produzione fisica avviene tramite una pipeline ben definita: il modello viene elaborato da uno slicer o da un software CAM, che genera automaticamente le traiettorie macchina necessarie alla stampa o alla lavorazione.
	Esistono però tecniche di rappresentazione della forma che non si basano sulla produzione volumetrica dell’oggetto, ma sulla generazione controllata di effetti ottici. Gli scratch hologram rientrano in questa categoria: la percezione della tridimensionalità non dipende dalla presenza di un solido, ma dal comportamento della luce riflessa da micro-incisioni realizzate su una superficie piana e riflettente. L’effetto visivo nasce dall’interazione tra direzione di osservazione, direzione della luce e orientazione locale dei graffi.
	In questo scenario il problema non è più quello di riempire un volume, bensì di determinare una distribuzione di traiettorie bidimensionali capaci di produrre, in condizioni controllate, un comportamento speculare coerente con una geometria tridimensionale di riferimento. Il modello 3D non viene quindi fabbricato direttamente, ma utilizzato come sorgente di informazione geometrica da tradurre in un pattern inciso su un piano.
	Dal punto di vista computazionale, questa trasformazione non è immediata. Una mesh triangolare descrive superfici attraverso vertici e facce; una macchina CNC, invece, esegue movimenti lungo traiettorie planari espresse in coordinate cartesiane e codificate in G-code. Occorre quindi definire una procedura che colleghi questi due livelli di rappresentazione: da un lato la struttura topologica e geometrica della mesh, dall’altro un insieme ordinato di archi o segmenti compatibili con i vincoli della fabbricazione digitale.
	Sono disponibili alcuni strumenti open source che affrontano la generazione di scratch hologram a partire da modelli 3D. Tali strumenti dimostrano la fattibilità dell’approccio, ma presentano limiti significativi in termini di stabilità, scalabilità e controllo dei parametri. In particolare, l’esecuzione può risultare instabile anche su modelli geometricamente semplici, rendendo difficile un utilizzo sistematico e riproducibile all’interno di una pipeline di fabbricazione.
	La motivazione del presente lavoro nasce quindi dall’esigenza di definire una pipeline computazionale chiara, formalizzata e controllabile, capace di trasformare un modello 3D in un insieme di traiettorie di incisione esportabili in modo coerente. L’obiettivo non è soltanto ottenere un effetto visivo, ma costruire un processo riproducibile che renda esplicite le scelte geometriche adottate e che possa essere analizzato, esteso e migliorato nel tempo.
	\section{Obiettivi della tesi}
	\section{Contributi del lavoro}
	\section{Struttura del documento}
	
	\chapter{Fondamenti teorici}
	
	\section{Scratch hologram e olografia analogica}
	\section{Riflessione speculare e modello geometrico}
	\subsection{Direzione della luce e direzione di osservazione}
	\subsection{Condizione di riflessione}
	\section{Proiezione tridimensionale su piano bidimensionale}
	\section{Dal punto 3D alla traiettoria di incisione}
%	
	\chapter{Stato dell’arte}
	
	\section{Scratch hologram manuali e approcci artistici}
	\section{Strumenti software esistenti}
	\subsection{Soluzioni open-source}
	\subsection{Limiti rispetto alla fabbricazione digitale}
	\section{Tecniche affini nella fabbricazione computazionale}
	\section{Posizionamento del presente lavoro}
	
	\chapter{Formalizzazione del problema}
	
	\section{Definizione della mesh triangolare}
	\section{Estrazione e rappresentazione degli spigoli}
	\section{Definizione dei parametri di vista e illuminazione}
	\section{Modello matematico per la generazione degli archi}
	\section{Problema della visibilità e dell’occlusione}
	
	\chapter{Architettura della pipeline computazionale}
	
	\section{Panoramica generale del sistema}
	\section{Caricamento e preprocessing del modello STL}
	\section{Campionamento degli spigoli}
	\section{Generazione delle traiettorie}
	\section{Culling e filtraggio delle traiettorie}
	\section{Esportazione in formato SVG}
	\section{Generazione del G-code}
	\section{Applicazione desktop per preview e parametrizzazione}
	
	\chapter{Implementazione}
	
	\section{Struttura modulare del software}
	\section{Scelte progettuali e librerie utilizzate}
	\section{Parametri configurabili}
	\section{Gestione delle prestazioni computazionali}
	\section{Problemi incontrati e soluzioni adottate}
	
	\chapter{Dal modello 3D al G-code}
	
	\section{Rappresentazione degli archi in ambiente CNC}
	\section{Conversione in comandi G2/G3}
	\section{Gestione delle unità e precisione numerica}
	\section{Vincoli e limiti delle macchine CNC}
	\section{Coerenza tra simulazione e fabbricazione}
	
	\chapter{Validazione e risultati}
	
	\section{Caso studio: modello cubico}
	\section{Caso studio: poliedro complesso (d20)}
	\section{Analisi dell’influenza dei parametri}
	\section{Valutazione qualitativa della resa visiva}
	\section{Discussione dei risultati}
	
	\chapter{Limiti e sviluppi futuri}
	
	\section{Limiti del modello geometrico adottato}
	\section{Miglioramento del culling tramite metodi di visibilità avanzati}
	\section{Estensione a modelli ottici più accurati}
	\section{Ottimizzazione dei percorsi CNC}
	\section{Validazione sperimentale su incisione reale}
	
	\chapter{Conclusioni}
	
	\section{Sintesi dei risultati}
	\section{Contributo della tesi}
	\section{Prospettive di ricerca future}
	

	\chapter{Title of the third chapter}
	A quotation \cite{APS1}
	
	A reference to a numbered formula \eqref{ps:2}
	
	A reference to the first section of the first chapter \ref{sec:11}
	
	\chapter*{Ringraziamenti}
	
	Ringraziamenti
	
	\phantom{p. 1}
	\clearpage
	\thispagestyle{empty}
	\phantom{p. 2}
	\clearpage
	\addcontentsline{toc}{chapter}{References}
	
	\begin{thebibliography}{9}
		\bibitem{APS1}
		M. F. Atiyah, V. K. Patodi, I. M. Singer (1975), \emph{Spectral asymmetry and Riemannian geometry. I}, Math.Proc. Cambridge Philos. Soc. \textbf{77}, 43-69.
		
		\bibitem{APS2}
		M. F. Atiyah, V. K. Patodi, I. M. Singer (1975), \emph{Spectral asymmetry and Riemannian geometry. II}, Math.Proc. Cambridge Philos. Soc. \textbf{78}, no. 3, 405-432.
		
		\bibitem{APS3}
		M. F. Atiyah, V. K. Patodi, I. M. Singer (1976), \emph{Spectral asymmetry and Riemannian geometry. III}, Math.Proc. Cambridge Philos. Soc. \textbf{79}, no. 1, 71-99.
		
	\end{thebibliography}
	
	
	
\end{document}