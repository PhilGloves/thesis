<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Scratch Hologram Simulation</title>
  <style>
    body { margin: 0; font-family: Segoe UI, Arial, sans-serif; background: #17181d; color: #f0f0f0; }
    .wrap { padding: 12px; max-width: 1200px; margin: 0 auto; }
    .toolbar { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
    .toolbar label { font-size: 14px; }
    .panel { background: #20222a; border: 1px solid #2d313a; border-radius: 8px; padding: 10px; }
    canvas { background: #0f1014; display: block; border-radius: 6px; width: 100%; height: auto; }
    input[type=range] { width: 190px; }
    .small { opacity: 0.8; font-size: 12px; margin: 6px 2px 10px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="toolbar panel">
      <label>View angle: <input id="angle" type="range" min="-90" max="90" step="1" value="0"/></label>
      <strong id="angleValue">0 deg</strong>
      <label>Cam yaw: <input id="camYaw" type="range" min="-45" max="45" step="1" value="0"/></label>
      <strong id="camYawValue">0 deg</strong>
      <label>Cam pitch: <input id="camPitch" type="range" min="-45" max="45" step="1" value="0"/></label>
      <strong id="camPitchValue">0 deg</strong>
      <label>Zoom: <input id="camZoom" type="range" min="60" max="220" step="1" value="100"/></label>
      <strong id="camZoomValue">100%</strong>
      <label>View gain: <input id="viewGain" type="range" min="100" max="600" step="10" value="280"/></label>
      <strong id="viewGainValue">2.8x</strong>
      <label>Arc stride: <input id="arcStride" type="range" min="1" max="12" step="1" value="4"/></label>
      <strong id="arcStrideValue">4</strong>
      <label>Arc limit: <input id="arcLimit" type="range" min="200" max="10000" step="100" value="2500"/></label>
      <strong id="arcLimitValue">2500</strong>
      <label>Arc min r: <input id="arcMinR" type="range" min="0" max="20" step="1" value="1"/></label>
      <strong id="arcMinRValue">1</strong>
      <label>Arc alpha: <input id="arcAlpha" type="range" min="2" max="80" step="1" value="20"/></label>
      <strong id="arcAlphaValue">20%</strong>
      <label><input id="showArcs" type="checkbox" checked/> Show arcs</label>
      <label><input id="showWire" type="checkbox" checked/> Show simulated profile</label>
    </div>
    <div class="small">Camera orbit is 3D-projected. Increase View gain if angle motion feels too subtle.</div>
    <div class="panel">
      <canvas id="sim" width="246" height="247"></canvas>
    </div>
  </div>
  <script>
    const data = {"minArcRadius":6.0,"camera":{"po":[0.9,9.008,23.978],"pr":[0.937,8.29,0.472],"lookUp":[0.0,1.0,0.0],"currentScale":0.7239993109254925,"zf":25.0,"canvasWidth":710,"canvasHeight":549},"vertices":[[-5.0,-5.0,-10.0],[-5.0,-5.0,0.0],[-5.0,5.0,0.0],[-5.0,5.0,-10.0],[5.0,5.0,0.0],[5.0,5.0,-10.0],[5.0,-5.0,0.0],[5.0,-5.0,-10.0]],"edges":[[0,1,32],[1,2,32],[2,3,32],[3,0,32],[2,4,32],[4,5,32],[5,3,32],[4,6,32],[6,7,32],[7,5,32],[6,1,32],[0,7,32]]};
    const canvas = document.getElementById('sim');
    const ctx = canvas.getContext('2d');
    const angleInput = document.getElementById('angle');
    const angleValue = document.getElementById('angleValue');
    const camYaw = document.getElementById('camYaw');
    const camYawValue = document.getElementById('camYawValue');
    const camPitch = document.getElementById('camPitch');
    const camPitchValue = document.getElementById('camPitchValue');
    const camZoom = document.getElementById('camZoom');
    const camZoomValue = document.getElementById('camZoomValue');
    const viewGain = document.getElementById('viewGain');
    const viewGainValue = document.getElementById('viewGainValue');
    const arcStride = document.getElementById('arcStride');
    const arcStrideValue = document.getElementById('arcStrideValue');
    const arcLimit = document.getElementById('arcLimit');
    const arcLimitValue = document.getElementById('arcLimitValue');
    const arcMinR = document.getElementById('arcMinR');
    const arcMinRValue = document.getElementById('arcMinRValue');
    const arcAlpha = document.getElementById('arcAlpha');
    const arcAlphaValue = document.getElementById('arcAlphaValue');
    const showArcs = document.getElementById('showArcs');
    const showWire = document.getElementById('showWire');
    const baseCamera = data.camera;
    const vAdd = (a,b) => [a[0]+b[0], a[1]+b[1], a[2]+b[2]];
    const vSub = (a,b) => [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
    const vDot = (a,b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
    const vCross = (a,b) => [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
    const vNorm = (a) => Math.sqrt(vDot(a,a));
    const vNormalize = (a) => { const n = vNorm(a); return (n < 1e-12) ? [0,0,0] : [a[0]/n,a[1]/n,a[2]/n]; };
    function rotY(v, ang) { const c=Math.cos(ang), s=Math.sin(ang); return [c*v[0]+s*v[2], v[1], -s*v[0]+c*v[2]]; }
    function rotX(v, ang) { const c=Math.cos(ang), s=Math.sin(ang); return [v[0], c*v[1]-s*v[2], s*v[1]+c*v[2]]; }
    function buildCameraState() {
      const yaw = Number(camYaw.value) * Math.PI / 180.0;
      const pitch = Number(camPitch.value) * Math.PI / 180.0;
      const zoom = Number(camZoom.value) / 100.0;
      const pr = baseCamera.pr;
      const dir = vSub(baseCamera.po, pr);
      const look = baseCamera.lookUp;
      const dirRot = rotX(rotY(dir, yaw), pitch);
      const lookRot = vNormalize(rotX(rotY(look, yaw), pitch));
      return {
        po: vAdd(pr, dirRot),
        pr: pr,
        lookUp: lookRot,
        currentScale: baseCamera.currentScale * zoom,
        zf: baseCamera.zf,
        canvasWidth: baseCamera.canvasWidth,
        canvasHeight: baseCamera.canvasHeight,
      };
    }
    function buildModelToWindow(cam) {
      const n = vNormalize(vSub(cam.po, cam.pr));
      let u = vCross(cam.lookUp, n);
      u = vNormalize(u);
      const v = vCross(n, u);
      const m11=u[0], m12=u[1], m13=u[2], m14=-vDot(u,cam.po);
      const m21=v[0], m22=v[1], m23=v[2], m24=-vDot(v,cam.po);
      const m31=n[0], m32=n[1], m33=n[2], m34=-vDot(n,cam.po);
      const p43 = -1.0 / ((Math.abs(cam.zf) < 1e-12) ? 1e-5 : cam.zf);
      const baseScale = cam.canvasWidth / 17.0;
      const scale = baseScale * cam.currentScale;
      return {
        m11,m12,m13,m14,m21,m22,m23,m24,m31,m32,m33,m34,
        p43, scale, tx: cam.canvasWidth / 2.0, ty: cam.canvasHeight / 2.0
      };
    }
    function projectPoint(p, m) {
      const x = p[0], y = p[1], z = p[2];
      const v1 = m.m11*x + m.m12*y + m.m13*z + m.m14;
      const v2 = m.m21*x + m.m22*y + m.m23*z + m.m24;
      const v3 = m.m31*x + m.m32*y + m.m33*z + m.m34;
      const w = (m.p43 * v3) + 1.0;
      if (!Number.isFinite(w) || Math.abs(w) < 1e-9) return null;
      const vx = (v1 / w) * m.scale + m.tx;
      const vy = -((v2 / w) * m.scale) + m.ty;
      const vz = v3 / w;
      if (!Number.isFinite(vx) || !Number.isFinite(vy) || !Number.isFinite(vz)) return null;
      return [vx, vy, vz];
    }
    function pointAtAngleProjected(p, deg, nView, gain) {
      const dist = (p[2] - nView) * gain;
      const cx = p[0];
      const cy = p[1] - dist / 2.0;
      const oy = dist / 2.0;
      const t = deg * Math.PI / 180.0;
      const x = cx - oy * Math.sin(t);
      const y = cy + oy * Math.cos(t);
      return [x, y];
    }
    function draw() {
      const angle = Number(angleInput.value);
      angleValue.textContent = `${angle.toFixed(0)} deg`;
      camYawValue.textContent = `${Number(camYaw.value).toFixed(0)} deg`;
      camPitchValue.textContent = `${Number(camPitch.value).toFixed(0)} deg`;
      camZoomValue.textContent = `${Number(camZoom.value).toFixed(0)}%`;
      viewGainValue.textContent = `${(Number(viewGain.value) / 100.0).toFixed(1)}x`;
      arcStrideValue.textContent = `${Number(arcStride.value).toFixed(0)}`;
      arcLimitValue.textContent = `${Number(arcLimit.value).toFixed(0)}`;
      arcMinRValue.textContent = `${Number(arcMinR.value).toFixed(0)}`;
      arcAlphaValue.textContent = `${Number(arcAlpha.value).toFixed(0)}%`;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const cam = buildCameraState();
      const m = buildModelToWindow(cam);
      const prView = projectPoint(cam.pr, m);
      if (!prView) return;
      const nView = prView[2];
      const proj = new Array(data.vertices.length);
      for (let i = 0; i < data.vertices.length; i++) {
        proj[i] = projectPoint(data.vertices[i], m);
      }
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of proj) {
        if (!p) continue;
        if (p[0] < minX) minX = p[0];
        if (p[1] < minY) minY = p[1];
        if (p[0] > maxX) maxX = p[0];
        if (p[1] > maxY) maxY = p[1];
      }
      if (!Number.isFinite(minX) || !Number.isFinite(minY)) return;
      const tx = (canvas.width / 2.0) - ((minX + maxX) / 2.0);
      const ty = (canvas.height / 2.0) - ((minY + maxY) / 2.0);
      const gain = Number(viewGain.value) / 100.0;
      if (showArcs.checked) {
        const stride = Math.max(1, Number(arcStride.value));
        const limit = Math.max(100, Number(arcLimit.value));
        const minR = Math.max(0, Number(arcMinR.value));
        const alpha = Math.max(0.01, Number(arcAlpha.value) / 100.0);
        ctx.strokeStyle = `rgba(190,190,190,${alpha.toFixed(3)})`;
        ctx.lineWidth = 0.9;
        let drawn = 0;
        edgeLoop: for (const e of data.edges) {
          const p0 = proj[e[0]];
          const p1 = proj[e[1]];
          if (!p0 || !p1) continue;
          const samples = Math.max(2, e[2]);
          for (let k = 0; k < samples; k += stride) {
            const t = (samples <= 1) ? 0.0 : (k / (samples - 1));
            const px = p0[0] + (p1[0] - p0[0]) * t;
            const py = p0[1] + (p1[1] - p0[1]) * t;
            const pz = p0[2] + (p1[2] - p0[2]) * t;
            const dist = (pz - nView) * gain;
            const r = Math.abs(dist) / 2.0;
            if (r < minR || r < data.minArcRadius * 0.25) continue;
            const cx = px + tx;
            const cy = (py - dist / 2.0) + ty;
            const start = (dist > 0) ? 0 : Math.PI;
            ctx.beginPath();
            ctx.arc(cx, cy, r, start, start + Math.PI, false);
            ctx.stroke();
            drawn += 1;
            if (drawn >= limit) break edgeLoop;
          }
        }
      }
      if (showWire.checked) {
        ctx.strokeStyle = 'rgba(245,245,245,0.92)';
        ctx.lineWidth = 1.5;
        for (const edge of data.edges) {
          const q1 = proj[edge[0]];
          const q2 = proj[edge[1]];
          if (!q1 || !q2) continue;
          const p1 = pointAtAngleProjected(q1, angle, nView, gain);
          const p2 = pointAtAngleProjected(q2, angle, nView, gain);
          ctx.beginPath();
          ctx.moveTo(p1[0] + tx, p1[1] + ty);
          ctx.lineTo(p2[0] + tx, p2[1] + ty);
          ctx.stroke();
        }
      }
    }
    angleInput.addEventListener('input', draw);
    camYaw.addEventListener('input', draw);
    camPitch.addEventListener('input', draw);
    camZoom.addEventListener('input', draw);
    viewGain.addEventListener('input', draw);
    arcStride.addEventListener('input', draw);
    arcLimit.addEventListener('input', draw);
    arcMinR.addEventListener('input', draw);
    arcAlpha.addEventListener('input', draw);
    showArcs.addEventListener('change', draw);
    showWire.addEventListener('change', draw);
    draw();
  </script>
</body>
</html>
